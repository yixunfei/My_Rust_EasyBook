### 1. 函数

#### 1.1 函数定义
   函数定义以关键字 `fn` 开始，后跟函数名、参数列表、返回类型（可选）和函数体。基本形式如下：
```Rust
  fn function_name(param_list) -> return_type {
    // 函数体
}
```
- **函数名**：遵循Rust的标识符命名规则，通常采用 snake_case（小写字母加下划线）。
- **参数列表**：括号内列出零个或多个参数，每个参数由名称、冒号、类型组成，多个参数间以逗号分隔。可选参数目前通过包装成`Option<T>`类型来模拟。
- **返回类型**：如果函数有返回值，使用箭头 `->` 后跟返回类型。如果没有显式返回类型，Rust 会根据函数体最后一行表达式的类型推断返回类型。*若函数无返回值，则返回类型为 ()，即空元组*。

*Rust鼓励使用文档注释（以 /// 开头的多行注释）来为函数编写文档，这些注释可以通过 `cargo doc` 命令生成API文档。*
#### 1.2 参数与参数模式
参数不仅可以指定类型，还可以使用模式进行更复杂的绑定：
1. **简单变量绑定**：如同在其他上下文中一样，直接使用变量名绑定参数值。
2. **元组结构**：适用于接收固定数量、类型已知的多个参数，如 (x, y)。
3. **解构结构体和枚举**：可以使用结构体或枚举的模式来直接绑定其字段或变体数据。
4. **引用与可变性**：通过 &、&mut 或 *mut 创建参数的引用或原始指针，控制对参数的访问权限和可变性。

> 函数定义时的参数叫作形式参数（**形参**），函数调用时传入的参数值叫做实际参数（**实参**）。函数的调用要与函数的签名（**函数名、参数个数、参数类型、参数顺序、返回类型**）一致，也就是实参和形参要匹配。函数对于几乎所有语言都非常重要，实际上各种编程语言在实现时，都是以函数作为基本单元来组织栈上的内存分配和回收的，这个基本的内存单元就是所谓的**栈帧**（frame）,每次函数执行返回均为一个栈帧的入栈与出栈过程。绝大多数编程语言的通用基础，不做过多概述.

#### 1.3 函数体与返回值
函数体包含要执行的代码。返回值可以通过以下方式产生：
- **表达式结尾**：如果函数体是一个单一表达式，该表达式的值将成为返回值。
- **`return` 关键字**：在函数体内任何位置使用 return expr; 显式返回一个值。非必需，因为Rust鼓励使用表达式作为函数体。
- **`return;`**：在没有显式返回类型的函数中，返回 ()。在有返回类型的函数中，这是编译时错误。
- `?` 运算符：在返回 Result 类型的函数中，用于短路返回当前作用域内的 Err 值。相当于对 Result 进行解构并检查，遇到 Err 时直接返回，否则继续执行

#### 1.4 函数特征
- **函数是一等公民**：可以作为参数传递、存储在变量中、作为其他函数的返回值，体现了Rust对函数式编程的支持。
- **类型推断**：Rust支持类型推断，允许在某些情况下省略显式返回类型声明。
- **泛型**：函数可以接受泛型参数，使其能够处理多种类型，增加了代码复用性。
- **生命周期注解**：当函数涉及引用时，可能需要标注生命周期以确保借用规则得到满足。
- **属性**（`#[...]`）：函数可以附带属性以影响编译器行为，如`#[inline]`、`#[allow(dead_code)]` 等。
- **内联函数**：使用 `#[inline] `属性标记的函数会被编译器尝试内联展开以提高性能。
- **测试函数**：带有 `#[test]` 属性的函数被视为测试用例，由测试框架自动执行。

```Rust
println!("{}",bbb(123,get_abc()))  
fn get_abc() -> fn(i32)->i32{  
    return aaa;  
}  
fn aaa(i:i32)->i32{  
    let ret = i.overflowing_add(123);  
    if(ret.1){  
        return 0;  
    }  
    return ret.0;  
}  
fn bbb(a:i32,m:fn(i32)->i32) -> i32{  
    m(a) + a  
}
```

#### 1.5 Never type函数
~~(有的地方叫发散函数，感觉不是特别准确)~~
`Never type !`: 在 Rust 中，`!` 类型（被称为“never type”或“bottom type”）表示一个永远不可能存在或返回的值(相应的空返回函数是可以被返回的。如：`let a = aaa;`aaa是空返回函数)。

**用于表示函数永远不会正常返回的情况**，如 **panic、无限循环或编译时错误**。例如：

```Rust
   fn never_returns() -> ! {
       panic!("永远不会正常返回一个值，通过调用 panic! 导致程序立即停止执行");
   }
   
	fn infinite_loop() -> ! {
       loop {
           // 这个循环永远也不会结束，因此函数永不返回
       }
   }
```



### 2. 闭包
---

Rust中的闭包是一种强大且灵活的语言构造，它们能够捕获环境变量、实现多种捕获模式、具备多种调用约定，并能无缝融入Rust的类型系统和异步编程模型（其实就一个匿名函数）。闭包常用于高阶函数、闭包链式调用、事件处理、异步编程等场景，提供了一种简洁的方式来封装行为，并在需要时传递和调用。增强了代码的抽象能力和表达力。

#### 2.1 定义与语法

闭包使用管道符号 `||` 来定义，其基本形式如下：

```Rust
let closure = |parameters| {
    // 闭包体
    expression_or_statements
};
```
- **参数列表**：与函数类似，闭包可以接受零个或多个参数，参数之间用逗号分隔。
- **返回值**：闭包根据最后表达式的值隐式推断返回类型。如果需要显式返回类型，可以使用 -> Type 格式指定。这时就变成了`|| -> {}`
- **捕获变量**：闭包可以捕获其封闭作用域中的变量，分为以下几种捕获方式：
  - **通过引用捕获** ( `&` )：默认捕获外围变量的不可变引用。
  - **通过可变引用捕获** ( `&mut` )：需要显式指定，捕获外围变量的可变引用。
  - **通过值捕获** ( `move` )：需要显式指定，将外围变量的所有权转移给闭包。
也
#### \*2.2 闭包类型与traits

Rust的闭包类型系统基于三个核心 traits：
 1. **`Fn`**：闭包可以多次无副作用地调用，仅捕获外围变量的不可变引用。
 2. **`FnMut`**：闭包可以多次有副作用地调用，捕获外围变量的可变引用。
 3. **`FnOnce`**：闭包只能调用一次，因为它获取了捕获变量的所有权（move捕获）。闭包的实际类型由其捕获方式和参数类型决定，是实现了相应 trait 的匿名类型。由于这些 trait 提供了统一的函数调用接口，闭包可以作为参数传递给期望这些 trait 类型的函数。


#### 2.3 捕获模式

闭包可以根据需要捕获外围变量,这也是闭包最主要的使用场景，特别是多线程环境中。
捕获方式分为：
 - **隐式捕获**：闭包会自动捕获其使用到的外围变量，编译器会根据使用情况选择合适的捕获方式。
 - **显式捕获**：通过在参数列表之前使用 move 关键字，强制闭包通过所有权转移捕获所有外围变量。
   - `-move`：如果闭包需要获取外部变量的所有权，即在闭包内部修改或消耗该变量，或者该变量的类型不满足借用条件，闭包会通过移动（move）方式捕获该变量。这意味着变量的所有权从其原始作用域转移到闭包内部，原始作用域不再有权访问该变量。
  - `-&`：如果闭包仅需读取外部变量的值且变量类型满足借用条件，闭包会通过不可变借用（&）方式捕获该变量。变量保持其原始作用域的所有权，闭包获得一个指向其值的不可变引用。
  - `-&mut`：如果闭包需要修改外部变量的值且变量类型满足借用条件，闭包会通过可变借用（&mut）方式捕获该变量。同样，变量保持其原始作用域的所有权，闭包获得一个指向其值的可变引用。

```Rust
let moveValue = "aaaa";  
use std::thread;  
thread::spawn(move || {  
   println!("{}",moveValue);  
});
```
没有多线程情况下，只是一个例子。上面的代码创建了一个线程，然后在线程内部闭包函数中打印了外部变量moveValue的值

#### 2.4 闭包与函数指针

虽然闭包与函数在概念上相似，但闭包有一些独特的特性：
 - **匿名性**：闭包不需要名称，可以在需要时即时定义。
 - **灵活性**：闭包可以捕获外围变量，而函数不能。
- **类型差异**：闭包是具有一种特定类型的匿名结构体实例，而函数有固定的函数指针类型。

#### 2.5 闭包作为参数与返回值

闭包因其灵活性常作为高阶函数的参数或返回值：
 - **作为参数**：接受闭包作为参数的函数（如迭代器的 `map`、`filter` 等）可以将计算推迟到调用时执行，实现延迟计算或策略模式。
 - **作为返回值**：返回闭包的函数可以动态生成行为，便于实现工厂模式或回调机制。

#### \*2.6 闭包与async

闭包可以与 `async` 关键字结合，形成异步闭包（`async 闭包`），用于定义异步计算任务：
 ```Rust
 let async_closure = async move |param| {
    // 异步闭包体
    async_expression_or_statements
 };
```


### 3. 模块
---

Rust中的`模块（module）`是组织代码的基础结构，用于封装相关功能、数据结构和常量，提高代码的可读性、可维护性和重用性。

``
```Rust
mod garden;
```

```
backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden              // 子目录
    │   └── vegetables.rs
    ├── garden.rs           // 与子目录同名的.rs文件，表示这个模块的入口
    └── main.rs
```

#### 3.1 模块定义与结构

- **模块定义**：使用关键字 mod 来定义一个模块。模块可以嵌套，形成层次化的模块树结构。
 ```Rust
 mod module_name {
    // 模块内容
 }
```
- **文件结构与模块映射**：Rust通过源文件布局与mod关键字相结合来组织模块。每个源文件对应一个顶级模块，子模块可以分别在独立的文件中定义，也可以在同一文件内使用内联模块定义。

#### 3.2 模块路径与导入

- **模块路径**：通过.分隔的序列来标识模块及其成员。例如，`crate::module_a::sub_module::function` 表示从 `crate` 根开始，经过 `module_a` 和 `sub_module`，访问名为 `function` 的函数。
- **导入（==`use`==）**：使用 `use` 关键字将模块路径引入到当前作用域，简化后续引用。可以使用 use 语句的多种形式来导入单个项、整个模块或重命名导入。
 ```Rust
 use crate::module_a::function_name;
 use crate::module_b as mb;
 use crate::module_c::{StructName, enum_variant, constant};
 ```
#### 3.3 可见性规则

- **默认私有性**：Rust中的所有项（函数、结构体、枚举、常量、模块等）默认对外部是私有的（`private`），只能在其定义的模块及其子模块中访问。
- **公有性声明**：使用 ==`pub`== 关键字来声明项为公有（`public`），允许外部模块通过其完全限定的模块路径进行访问。
- **`pub(crate)`**：声明项对当前 `crate` 内部可见，但对 `crate` 外部不可见，适用于内部共享但不暴露给外部使用者的项。

#### 3.4 super与self关键词
- ==`super`==：用于引用当前模块的直接父模块。例如，`super::function` 访问父模块中的 `function`。
- ==`self`==：在 `use` 语句中，`self` 代表当前模块。如 `use self::sub_module::Item;` 导入当前模块下 `sub_module` 中的 `Item`。

#### 3.5 模块树与Cargo工作空间

- **模块树**：Rust项目通常构成一个模块树结构，其中主 `crate`（通常是`src/lib.rs或src/main.rs`）作为根模块，其他模块分布在各源文件中。
- **Cargo工作空间**：大型项目可以使用Cargo工作空间（workspace）来管理多个相互依赖的`crate`。每个成员 `crate` 有自己的模块结构，工作空间提供了一种集中管理和构建的方式

#### 3.6 模块与代码组织原则

- **关注点分离**：将相关功能封装在各自的模块中，避免不同功能间的耦合。
- **最小可见性原则**：尽可能保持项的私有性，仅将必要的接口公之于众，降低外部使用者误用的风险。
- **合理使用`use`语句**：适度导入有助于减少长路径引用，但过度导入可能导致作用域混乱。平衡好代码的紧凑性与可读性。


### 4. 测试
---

Rust提供了内置的测试框架来支持单元测试、集成测试以及性能基准测试。

#### 4.1 测试组织与标识

**测试函数**：测试函数以 `#[test]` 属性装饰，表示这是一个测试用例。测试函数通常不接受参数，也不返回值。
```Rust
#[test]
fn test_example() {
    // 测试代码
}
```
**测试模块**：测试函数通常放置在源码文件对应的`tests`目录下的同名模块中，或者与被测代码位于同一个模块内。这有助于组织测试代码并与生产代码分离。

#### 4.2 测试执行

- ==`cargo test`==：使用 `cargo test` 命令启动测试运行器，它会编译并执行所有标记为测试的函数。
- **过滤与分组**：通过命令行选项可以筛选要运行的测试，如按名称、按测试函数属性（如`#[cfg(test)]`、`#[ignore]`）等。

#### 4.3 测试结果与断言

**`assert!`家族**：Rust提供了一系列断言宏，如 `assert!`、`assert_eq!`、`assert_ne! `等，用于验证程序状态或预期结果。断言失败时，测试会立即终止并报告失败。
```Rust
assert_eq!(result, expected_value);
```
**测试输出**：测试运行器会显示每个测试的执行结果（通过/失败/忽略）、耗时以及失败时的断言消息和堆栈跟踪。

#### 4.4 测试配置

**设置环境**：在测试函数中使用 `setup/teardown` 函数或 `before_each/after_each` 注解来初始化和清理测试环境。
**测试参数化**：使用第三方库（如 `proptest`、`quickcheck`）实现参数化测试，为同一逻辑提供多种输入组合。

#### 4.5 集成测试

- `#[cfg(test)]`：用于条件编译，包裹在测试代码周围的 `#[cfg(test)]` 使测试代码仅在运行测试时编译。
- `extern crate`与`use`：在集成测试中，可能需要引入正在测试的crate或其内部模块，使用 `extern crate`（2018版Rust之前的项目）或 `use` 语句来完成。

#### 4.6 基准测试（Benchmarking）

- `cargo bench`：使用 `cargo bench` 命令运行基准测试。由于基准测试通常需要精确计时，因此需要使用nightly版本的Rust编译器。
- `#[bench]`：基准测试函数使用` #[bench]` 属性标记，通过`test::Bencher`参数接收一个计时器对象，用于记录测试代码的执行时间。

```Rust
#[bench]
fn bench_example(b: &mut test::Bencher) {
    b.iter(|| {
        // 被测量的代码块
    });
}
```

#### 4.7 测试最佳实践

- **覆盖率**：使用工具（如`tarpaulin`）计算测试覆盖率，确保测试覆盖重要的代码路径。
- **快速失败**：尽早触发断言，避免无效计算浪费资源。一旦发现错误，立即停止测试。
- **独立性**：测试用例之间不应互相影响，每个测试应准备自己的数据和环境。
- **文档性**：测试用例应反映预期行为，失败时提供的信息应有助于定位问题。

