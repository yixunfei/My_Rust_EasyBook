![[Rust基础类型.png]]
### 1. Rust基础类型
---
##### 1.1 定义变量及赋值

###### 1.1.1 变量定义
Rust中使用`let`关键字定义变量和其他大多数语言一样一般使用`=`对变量赋值。同时使用`const`定义常量。

>>注意：在Rust中个人**非常不建议**，将`=`号单纯的与其他语言中的赋值相对应。在这里语义上翻译为人类语言中的`交给`或`移交`更加贴切(将在所有权和单个实体时着重体现。`=`表示的是将一个东西交给一个变量，而不是创建这里的是基本字面量。确切的说，创建应该是`::new`相关语义)。忘掉之前习惯了的赋值叫法。

在变量名后使用`:`指定类型。基本格式如下:
```
let <variable_name>: <type> = <initial_value>;

<variable_name> 是你要为变量指定的名字。
<type> 是变量的数据类型（可选）。如果编译器可以从初始值推断出类型，则可以省略类型注解。
<initial_value> 是变量的初始值。根据Rust的严格初始化原则，局部变量通常需要在定义时就赋予一个初始值。
```
如：
```
let age: u32 = 25;
let name = "Alice"; // 类型 `&'static str` 由编译器自动推断
```


###### 1.1.2 自动推导类型
当使用自动推导类型时：
1. **基于初始值推断**：
	当使用 let 关键字声明变量并立即赋予一个初始值时，编译器会根据这个初始值的类型来推断变量的类型。
  ```
	   let x = 42; // 类型推断为 i32
	   let y = 3.14; // 类型推断为 f64
	   let s = "hello"; // 类型推断为 &str
  ```
2. **类型上下文约束**：
	如果变量没有直接赋值，但在其使用的上下文中存在明确的类型约束，编译器也会尝试推断类型。例如，在函数参数、返回类型、结构体成员或数组元素等位置。
	```
   fn process_number(num: i32) {
       let doubled = num * 2; // 类型推断为 i32，因为 `num` 是 i32 类型
   }
	```
3. **类型统一**：
	在某些情况下，编译器需要推断多个变量或表达式的共同类型。此时，它会选择一个能够容纳所有可能值的最小通用类型。例如，当将不同整数类型相加时，结果类型通常是它们之中最大的。
	```
	   let a: u8 = 10;
	   let b: u16 = 20;
	   let sum = a + b; // 类型推断为 u16，因为 u8 可以隐式提升到 u16 进行加法运算
	```

- 推断出的常见类型:
 - **整数类型**：根据字面量大小和有无负号，编译器可能会推断出 i8, i16, i32, i64, u8, u16, u32, u64, isize, 或 usize 类型。
 - **浮点数类型**：小数字面量通常会被推断为 f64 类型。若需要 f32 类型，可以通过类型后缀 .0f32 或类型注解指定。
 - **布尔类型**：字面量 true 或 false 会被推断为 bool 类型。
 - **字符类型**：单引号 'a' 包围的单个字符会被推断为 char 类型。
 - **字符串字面量**：双引号 "Hello, world!" 包围的文本会被推断为 &'static str 类型。
 - **数组**：根据初始化列表中的元素类型和数量，编译器会推断出相应的数组类型，如 [i32; 5]。
 - **元组**：根据构成元组的各个元素类型，编译器会推断出对应的元组类型，如 (i32, String, bool)。
 - **结构体和枚举**：当创建结构体或枚举实例时，编译器会根据实例化的具体类型推断出变量类型。
 - **闭包和函数指针**：根据闭包或函数的签名，编译器会推断出适当的闭包类型（如 impl Fn(Args) -> Return）或函数指针类型（如 fn(Args) -> Return）。

> 需要注意的是，尽管Rust的类型推断功能强大，但在某些复杂场景下或者为了提高代码可读性，仍然建议显式指定类型。此外，当编译器无法准确推断类型或推断出的类型不符合预期时，应提供类型注解以消除歧义。

###### 1.1.3 可变性与不可变性
**==Rust变量默认是不可变的==**，即一旦定义并赋值后，其值就不能被改变。这种设计有助于防止意外修改数据，提高代码的安全性和可预测性。若需定义一个可变变量，需要在 let 关键字后面添加 ==mut== 关键字：
```
let mut count: u32 = 0;
count += 1; // 可变变量可以被重新赋值或修改
```
虽然不可变但是可以重新定义新变量赋值，覆盖掉
```
    let a = 123;
    let a = a + 1;
    //下面注释的代码会报错，因为a是不可变的
    //a = a + 1;
    println!("{}", a);
```

###### 1.1.4 常量`const`和`let` 不可变变量的区别:

1. **作用域和生命周期:**
  - **常量**: 常量的作用域通常是全局的或模块级别的。一旦定义，它们在整个程序或模块内可见，无需通过任何作用域限制符（如 `pub`）来显式导出。常量可以在任何静态上下文中被引用，包括其他常量、静态变量的初始化以及编译时常数表达式。
  - **不可变变量**: 不可变变量通常具有更局部的作用域。它们在 `let` 语句下声明，并且其可见性和生命周期受限于其所在的函数、代码块或结构体实例。如果希望让不可变变量在更大范围内可用，可能需要将其封装在结构体、枚举或接口中，或者使用 `pub` 关键字进行导出
2.  **初始化时机与位置**:
 - **常量**: 常量必须在编译时就能确定其值，这意味着它们的值可以是字面量、编译时常数表达式的结果，或者是链接到其他已知常量或编译时常量函数的调用结果。**常量不允许引用运行时才能确定的值**，如函数返回值或依赖于环境状态的值。
 - **不可变变量**: 不可变变量可以在运行时动态初始化，其值可以来源于函数调用、计算表达式或其他任何在程序执行过程中能够确定的值。这提供了更大的灵活性，特别是在处理依赖于用户输入、配置文件、系统状态等动态数据的情况。
3. **内存布局与优化:**
 - **常量**: 由于编译时就知道其确切值，编译器可以对常量进行内联、折叠、常数传播等优化，甚至完全消除不必要的常量存储和访问。这可能导致常量没有实际的内存地址，而是直接嵌入到使用它的代码中，从而提高效率并减少内存占用。
 - **不可变变量**: 虽然不可变变量的值在声明后不会改变，但它仍然会在运行时分配内存，并有一个固定的内存地址。编译器可能会进行某些优化，比如避免复制不可变数据，但相比常量，其内存布局和优化潜力通常较为有限。
4. **重声明与遮蔽:**
 - **常量**: 在同一个作用域内，不允许重声明同名常量。如果需要更改常量的值或类型，必须选择一个不同的名称。
 - **不可变变量**: Rust 允许在同一作用域内使用相同的 `let` 语句多次声明不可变变量，这种行为被称为“遮蔽”（`shadowing` 有的地方也翻译为“隐藏”）。每次遮蔽都会创建一个新的、同名的不可变变量，隐藏先前声明的变量。尽管新变量也是不可变的，但这种机制允许在不同阶段或循环迭代中使用相同名称但具有不同值的变量。

###### 1.1.4 复合赋值操作
类似于其他编程语言，Rust支持一系列复合赋值操作符，这些操作符同时完成计算和赋值操作。例如：
```
let mut balance: f64 = 100.0;
balance += 50.0; // 相当于 balance = balance + 50.0
```
在这个例子中，balance 变量的值增加了 50.0，而无需显式地读取旧值、执行加法操作，然后再赋回给变量。常用的复合赋值操作符包括：
```
+=
-=
*=
/= （除法，对于整数类型，结果将是浮点数）
%= （求余数）
<<= （左移）
= （右移）
&= （按位与）
^= （按位异或）
|= （按位或）
```

###### 1.1.5 代码块作用域遮蔽变量
虽然Rust不允许在同一作用域内多次定义同名不可变变量，但它允许在内部作用域中使用相同的变量名来“隐藏”外部作用域的同名变量。这样做实际上是在内部作用域定义了一个新的、具有相同名称但可能不同类型的变量，从而覆盖外部变量的可见性。外部变量在其作用域外依然有效。 
```
let number = 10;
{
    let number = "ten"; // 在内部作用域中隐藏外部的 `number` 变量
    println!("{}", number); // 输出 "ten"
}
println!("{}", number); // 输出 10，因为此处访问的是外部作用域的原始 `number` 变量
```

##### 1.2数字类型
###### 1.2.1 整型数字
与一些动态语言不同，Rust 中的数字类型是区分位数的。基本上有符号i+长度，无符号u+长度即可。`isize` 和 `usize` 的位数与具体 CPU 架构位数有关。CPU 是 64 位的，它们就是 64 位的，CPU 是 32 位的，它们就是 32 位的。这些整数类型可以在写字面量的时候作为后缀跟在后面，来直接指定值的类型，比如 `let a = 10u32;` 就定义了一个变量 a，初始化成无符号 32 位整型，值为 10。在没有指定类型的数字默认是i32

| 长度       | 有符号   | 无符号   |
| -------- | ----- | ----- |
| 8-bit    | i8    | u8    |
| 16-bit   | i16   | u16   |
| 32-bit   | i32   | u32   |
| 64-bit   | i64   | u64   |
| 128-bit  | i128  | u128  |
| arch-bit | isize | usize |
|          |       |       |

**整数字面量的辅助写法**
Rust 提供了灵活的数字表示方法，便于我们编写整数字面量。比如：
```
十进制字面量 98_222，使用下划线按三位数字一组隔开
十六进制字面量 0xff，使用0x开头
8进制字面量 0o77，使用0o（小写字母o）开头
二进制字面量 0b1111_0000，使用0b开头，按4位数字一组隔开
字符的字节表示 b'A'，对一个ASCII字符，在其前面加b前缀，直接得到此字符的ASCII码值
```

思考题：
```
fn avg(a:u32,b:u32){
	//请在此处打印并求出传入参数a和b的平均值整数(只保留整数部分)
}
```


答案：
```
fn main() {
    println!("{}", avg(3, 2));
}

fn avg(a:u32,b:u32) -> u32{
    (a & b) + ((a ^ b) >> 1)
}
```

**整型溢出**
在Rust中当数值溢出时，默认情况下分为两种情况。当编译期已知数值溢出，将会编译不通过。当运行时才能发现数值溢出时,就会导致问题
```
fn main() {
   let a:u8 = 254;//255
   let b:u8 = "123".parse().unwrap();
    //这里如果使用编译期已知的数值，编译将报错
    //let b:u8 = u8::MAX;
   let r:u8 = a + b;
   print!("结果值：\t {}", r);
}
```
>**启用溢出检查（Checked Overflow）:**
>> ==默认行为==(dev配置，默认的`cargo build`)：Rust编译器默认会在开发模式（debug配置）下启用溢出检查。这意味着当整数运算（如加法、减法、乘法、除法等）可能导致溢出时，Rust会阻止程序继续运行，并抛出一个运行时错误。具体的错误类型为`std::num::TryFromIntError`（对于`try_from()`等方法）或`std::overflowing::OverflowingArithmetic`（对于`overflowing_add()`等方法）。这样可以及时发现潜在的逻辑错误，保证程序的健壮性。
>> 
**禁用溢出检查（Unchecked Overflow）:**
>>==发布模式==（release配置,`cargo build --release`）：在发布模式下，编译器通常会优化代码并默认禁用溢出检查，以提高程序的运行效率。在这种情况下，整数溢出会导致未定义行为（Undefined Behavior, UB）。这可能表现为数值默默地环绕（wrap around）、程序崩溃、产生错误的结果，甚至看似正常运行但实际上引入了难以察觉的逻辑错误。Rust鼓励开发人员在发布版本中也保持对整数溢出的严谨处理，以避免因UB导致的潜在安全风险。若有意在开发模式下模拟发布模式的行为，可以使用`#[cfg_attr(debug_assertions, deny(overflowing_literals))]`属性或全局开启`#![allow(overflowing_literals)]`
>>
**手动处理溢出:**
>>Rust提供了多种方法来显式处理可能的溢出情况，允许开发者选择适合其应用场景的策略。例如：
>>> - 使用`checked_add()`, `checked_sub()`, `checked_mul()`等方法，这些方法在发生溢出时返回`None`，否则返回包含结果的`Some(_)`.
>>> - 使用`overflowing_add()`, `overflowing_sub()`,` overflowing_mul()`等方法，这些方法返回一个元组，其中第一个元素是计算结果，第二个元素是一个布尔值，指示是否发生了溢出。
>>> - 使用`wrapping_add()`, `wrapping_sub()`, `wrapping_mul()`等方法，这些方法在发生溢出时默默地环绕（wrap around）到类型所能表示的范围内。


> **==一定要考虑溢出情况！在使用时，特别是运行时才能发现的溢出！除非确定不会出问题，否则默认考虑溢出情况。所以推荐使用`overflowing_`系列函数处理可能溢出的运算！==**
```
//#![allow(overflowing_literals)]
fn main() {
   let a:u8 = 254;
//    let b:u8 = "123".parse().unwrap();
   let b:u8 = u8::MAX;
   //使用overflowing_计算
   let (r,is_overflow) = a.overflowing_add(b);
   print!("结果值：\t {} \t 是否溢出：\t {}", r,is_overflow);
}
```
###### 1.2.2 浮点数
浮点数有两种类型：`f32` 和 `f64`，和整数分别代表 32 位浮点数类型和 64 位浮点数类型。它们也可以跟在字面量的后面，用来指定浮点数值的类型，比如 `let a = 3.14f32;` 就定义了一个变量 a，初始化成 32 位浮点数类型，值为 3.14。在没有指定类型的小数，默认情况下采用64位浮点数.


##### 1.3布尔类型
Rust 中的布尔类型为 `bool`，它只有两个值，`true` 和 `false`。内存占用 1 个字节。Rust 不会自动将其他类型隐式转换为 bool（比如 `let a:bool = 1;` 这种情况是不允许的），其他没啥需要注意的。

##### 1.4字符
Rust 中的字符类型是 char，值用单引号括起来。
```
fn main() {
    let c = 'z';
    let z: char = 'ℤ'; 
    let heart_eyed_cat = '🐕';
    let t = '咸';
}
```
- Rust 的 char 类型代表的是一个 ==**Unicode**== 标量值，而非字节或特定编码下的字符。每个 char 对象占用 4 个字节（32位）。这意味着它可以表达各种符号，比如中文符号、emoji 符号等。不同于C的ASCII。

- 可以使用标准比较运算符（`==, !=, <, <=, >, >=`）对 char 值进行比较。这些比较**基于 Unicode 标量值的顺序**，而不是视觉外观或排序习惯。

- 不同的 char 在屏幕上可能占据不同的宽度（如全角字符和半角字符）。如果需要计算文本的显示宽度或进行对齐操作，需要使用专门的库（如 unicode-width）来处理字符宽度，因为 char 类型本身并不直接提供宽度信息。

- 在 Rust 代码中，使用反斜杠 `\`进行转义 

- Rust 标准库提供了 `std::char` 模块，包含了用于检查字符类别（如字母、数字、标点等）的方法，如 `is_ascii()`, `is_digit()`, `is_alphabetic()`, `is_whitespace()` 等。这些方法有助于进行字符级别的文本处理和验证
##### 1.5字符串

Rust 中的字符串类型是 String。虽然中文表述上，字符串只比前面的字符类型多了一个串字，但它们内部存储结构完全不同。String 内部存储的是 Unicode 字符串的 UTF8 编码，而 char 直接存的是 Unicode 标量值（Unicode Scalar Value）。也就是说 **==String 不是 char 的数组==**。通过下面示例我们可以看到，Rust 字符串对 Unicode 字符集有着良好的支持。

```
let hello = String::from("السلام عليكم");
let hello = String::from("Dobrý den");
let hello = String::from("Hello");
let hello = String::from("שָׁלוֹם");
let hello = String::from("नमस्ते");
let hello = String::from("こんにちは");
let hello = String::from("안녕하세요");
let hello = String::from("你好");
let hello = String::from("Olá");
let hello = String::from("Здравствуйте");
let hello = String::from("Hola");
```

****USV和UTF-8编码区别：**

> Unicode Scalar Value (USV)：
	Unicode Scalar Value 指的是 Unicode 标准中定义的一个独立的抽象字符或符号的唯一数值标识，通常用十六进制形式表示，如 U+1F600 表示“笑脸”表情符号。每一个 USV 就是一个具体的 Unicode code point，在 Rust 中对应一个 char 类型的值。

>
>UTF-8 编码： UTF-8 是一种变长的 Unicode 编码方案，它将每个 Unicode 标量值（即 char）编码为一个或多个字节（8-bit 单元）。具体规则如下： 
  > 1. 对于 U+0000 至 U+007F 范围内的 ASCII 字符，UTF-8 编码与 ASCII 完全相同，每个字符占一个字节。
  >2. 对于 U+0080 至 U+07FF 的 BMP 中非 ASCII 字符，UTF-8 使用两个字节表示。
 > 3. 对于 U+0800 至 U+FFFF 的 BMP 中其他字符，UTF-8 使用三个字节表示。
>  4. 对于 U+10000 至 U+10FFFF 的辅助平面字符，UTF-8 使用四个字节表示。

同理，由于String保存的UTF-8编码是一种变长编码(有的使用两个字节有的使用三个字节)，所以Rust 中的 String 不能通过下标去访问。因为这样取出来的可能至少三个字节中的第一个字节，而不是一个标准的char的Unicode的4字节标量。如果需要从中获取字符可以使用方法如 `chars()`、`bytes()` 或 `split_whitespace()` 等遍历或切割字符串，或者使用 `char_indices()` 返回`(index, char)` 对来同时知道字节索引和对应的 char。
若要获取子字符串，可以使用 `&str` 切片语法，如` let substring = &string[start..end]`，但要注意 start 和 end 必须是有效的 UTF-8 边界索引。对于更复杂的文本处理，可以考虑使用专门的 Unicode 库（如` unicode-segmentation`）。

任何尝试插入非 UTF-8 字节序列的操作都会导致编译时或运行时错误。需要确保从外部源（如文件、网络）读取的数据经过适当的解码或验证为合法 UTF-8 后再放入 String。

**字符串字面量的转义**
与char相同，String特殊字符使用`'/'`转义。

**禁止转义的字符串字面量**
有时候，我们不希望字符串被转义，也就是想输出原始字面量。这个在 Rust 中也有办法，使用 `r""` 或 `r#""#`把字符串字面量套起来就行了。
```
fn main() {
    // 字符串字面量前面加r，表示不转义
    let raw_str = r"Escapes don't work here: \x3F \u{211D}";
    println!("{}", raw_str);
    // 这个字面量必须使用r##这种形式，因为我们希望在字符串字面量里面保留""
    let quotes = r#"And then I said: "There is no escape!""#;
    println!("{}", quotes);
    // 如果遇到字面量里面有#号的情况，可以在r后面，加任意多的前后配对的#号，
    // 只要能帮助Rust编译器识别就行
    let longer_delimiter = r###"A string with "# in it. And even "##!"###;
    println!("{}", longer_delimiter);
}
```

Rust 中的字符串字面量都**支持换行写**，默认把换行符包含进去。

直接使用 + 运算符或 format!() 宏拼接大量字符串会导致多次内存分配和复制操作，效率较低。对于批量构建字符串，推荐使用 `String::push_str()`、`write!()` 或`writeln!()` 函数，或者先收集到 `Vec<&str>` 中，最后一次性使用`join()` 方法合并。
使用 `format!()` 宏时，确保遵循其语法并正确处理占位符和参数类型。该宏在编译时生成格式化的字符串，提供了类似于 C 语言 `printf` 的功能，但具有类型安全检查。

##### 1.6 字节串

字节字符串字面量(Byte String Literal): 用于表示一个**固定长度**的字节序列
	当用字节表示数组时，可以使用字节串(其实就一个字节数组)。用 `b` 开头，双引号括起来。如 b"this is a byte string"。这时候字符串的类型已不是字符串，而是字节的数组 `[u8; N]`，N 为字节数。里面的字符都是按照它们在ASCII字符集中对应的单字节（8位）值来编码的。主要用于处理二进制数据、网络通信、文件I/O等场景。
	
```
fn main() {
    // 字节串的类型是字节的数组，而不是字符串了
    let bytestring: &[u8; 21] = b"this is a byte string";
    println!("A byte string: {:?}", bytestring);
    // 可以看看下面这串打印出什么
    let escaped = b"\x52\x75\x73\x74 as bytes";
    println!("Some escaped bytes: {:?}", escaped);
    // 字节串与原始字面量结合使用
    let raw_bytestring = br"\u{211D} is not escaped here";
    println!("{:?}", raw_bytestring);
}
```
注意：
> Byte string literals 每个字符在字节字符串字面量中都被视为单个字节（8位），其值等于该字符在ASCII表中的位置。因此**只能包含可打印的ASCII字符**（包括空格、标点符号等）以及ASCII控制字符（如制表符 `\t`、`换行符` `\n` 等）。超出ASCII范围的Unicode字符不能直接出现在字节字符串字面量中。如果需要处理非ASCII字符，应当使用普通字符串字面量（如 "你好"），然后通过适当编码（如UTF-8）将其转换为字节序列。
> 字节字符串字面量不支持字符串插值（如 `${}`），因为它们**旨在表示原始字节数据，而非可解析的文本**。若需要进行字符串插值，请使用普通字符串字面量，随后再进行必要的编码转换。
> 
##### 1.7数组
数组是一种**固定大小**(Rust中固定尺寸的数据类型可以直接放栈上，性能更高)的、同类型元素的有序集合。数组在内存中是连续存储的，其大小在编译时就必须确定。(这个应该不用再过多介绍概念什么的吧....)

Rust 中的数组是 `array` 类型，用于存储**同一类型**的多个值。数组表示成`[T; N]`，由中括号括起来，中间用**分号隔开**，分号**前面表示类型**，分号**后面表示数组长度**。
```
//显式初始化 列出所有元素来初始化数组：
let colors = ["red", "green", "blue"]; // 初始化一个含有3个字符串元素的数组
//默认初始化 数组元素将被默认初始化为该类型对应的零值
let mut counts: [u32; 10]; // 默认初始化为10个 u32 类型的零值（0）
//可变性 与其他类型一样，数组也可以指定为 mut可变或不可变：在不可变数组中，无法修改任何元素的值。而在可变数组中，可以改变元素值：
let mut mutable_array: [i32; 3] = [1, 2, 3];

```

数组的访问和其他很多语言一样，通过下标访问。
如下：
```
fn main() {
    let a: [i32; 5] = [1, 2, 3, 4, 5];
    let a = [1, 2, 3, 4, 5];
    let b = a[0]; 
    println!("{}", b)
    
    //迭代访问
	let colors = ["red", "green", "blue"];
    for color in colors.iter() {
	    println!("{}", color);
	}
}
```


> Rust主要崇尚于编译期尽可能多的解决发现问题，所以可以将*是否能在编译期计算出某个数据类型在运行过程中占用内存空间的大小*作为判断标准进行划分。由于固定大小，所以在编译时如果出现下标越界，越界访问的代码就会直接编译不通过。

**注意:** 

> 当需要动态获取指定数组下标时(要访问的下标可能是一个可变值，不能在编译期确定)，由于可能出现越界访问。导致运行时 `panic`。为了防止这种情况，可以使用 Rust 的 `get` 方法，它返回一个 `Option<&T>`，在索引无效时返回 `None`：
```
match colors.get(4) {
    Some(color) => println!("Fourth color: {}", color),
    None => println!("Index out of bounds"),
}
```
由于模式匹配和panic后面才会讲，所以这里记住可能越界时使用`get`方法访问返回可空对象就可以了。


**数组切片**：
通过切片操作可以获得数组的部分视图，表现为 `&[T]` 类型（对于不可变数组）或 `&mut [T]` 类型（对于可变数组）。切片**不拥有数据**，而是**指向原数组的一部分**：
```
let slice = &colors[1..3]; // 从索引1到索引2（不含）的切片
```

##### 1.8动态数组

Rust中动态数组是`Vec<T>` 类型(其实就一个起始指针+长度)，用于存储可变数量的同类型元素。相较于固定大小的数组，`Vec<T>` 具备在运行时动态调整容量的能力(不确定大小所以编译时没办法检查)，使其更加灵活和适应各种需要处理可变数量数据的场景。

**定义格式**：
```
//这里的 Type 是 Vec 中元素的类型。
let vector_name: Vec<Type>;
```
**创建并初始化** :
1. 使用 `Vec::new()` 创建空 `Vec`
```
let mut numbers: Vec<i32> = Vec::new();
```
2. 使用类型推断创建空 `Vec`
```
let mut numbers = Vec::new();
```
3. 使用数组字面量创建 `Vec`
```
let numbers = vec![1, 2, 3];
```
4. 使用 `vec![]` 宏创建带有初始值的 `Vec`
```
let words = vec!["apple", "banana", "cherry"];
```


>`::new()` 方法是 Rust 中常见的一种构造函数模式，用于创建特定类型的新实例。通常，结构体、枚举或一些复杂的类型会提供一个（或多个）`new 函数`作为其公共接口的一部分，用于创建经过适当初始化的实例。用于创建更复杂类型的新实例，如结构体、枚举或集合类型。
>
>与之相比，使用`=`号直接赋值定义通常指的是给变量直接赋一个已存在的值或实例，而这个值可能是：字面值,复合字面值,常量或变量,返回值等。往往没有额外的资源分配或复杂初始化逻辑



> `vec![]` 是 Rust 语言中一个方便快捷地创建 Vec（动态数组）的宏(在后面讲解,由于是内置宏，所以可以先记住这个命令和写法就可以了)。可以简洁地初始化一个带有初始元素的 Vec 数据结构。
> 
> 支持重复元素: 通过使用重复计数语法，可以轻松创建包含重复元素的 Vec。例如，`vec![0; 10]` 会生成一个长度为10、所有元素均为0的 `Vec<i32>`。即值为0的元素，重复10次

**Vec 的 长度**（`vec.len()`）： 是指当前存储的元素数量。
**Vec 的 容量**（`vec.capacity()`）： 是指已分配的内存空间可容纳的最大元素数量。长度始终小于或等于容量。

**常用操作**:
1. **添加元素**: `push()` 在末尾添加一个元素。
```
numbers.push(4);
```
2. **移除元素**: `pop()` 移除并返回最后一个元素。
```
if let Some(last_number) = numbers.pop() {
    println!("Popped number: {}", last_number);
}
```
3. **访问元素**:  与数组类似通过下标访问，但超出范围时会触发 `panic`。可以使用==`get()`== 返回 `Option<&T> `或 `Option<&mut T>` 以进行安全访问。
```
let first_number = numbers[0];  // 下标访问
let maybe_second_number = numbers.get(1);  // 安全访问
```
4. **更新元素**: 直接通过下标更新元素值即可
```
numbers[0] = 10;
```
5. **查询属性**: 
	`len()`: 返回 Vec 中元素的数量。
	`capacity()`: 返回当前分配的内部缓冲区容量，大于或等于实际元素数量。
```
println!("Length: {}, Capacity: {}", numbers.len(), numbers.capacity());
```
6. **扩容与收缩**:
	`reserve()`：预先为 Vec 分配额外的容量，以减少未来插入元素时的频繁内存重分配。
	`shrink_to_fit()`：尝试释放多余容量，将容量调整至与当前元素数量相等。
```
numbers.reserve(10);  // 预留额外10个元素的空间
numbers.shrink_to_fit();  // 尝试释放多余容量
```
7. **清除所有元素**: `clear()` 移除所有元素，保留原有容量
```
numbers.clear();
```
8. **迭代与切片**
	**迭代**: 和数组相同，可以使用 `for` 循环或其他迭代机制遍历 `Vec`。
	```
	for number in &numbers {
	    println!("{}", number);
	}
	```
	**切片**: 通过切片操作可以获取 `Vec` 的部分视图，表现为 `&[T]` 类型（对于不可变 Vec）或 `&mut [T]` 类型（对于可变 Vec）。
	```
	let slice = &numbers[1..3];  // 从索引1到索引2（不含）的切片
	```
9. **与数组的转换**：可以使用 `into_iter().collect()` 将 Vec 转换为固定大小的数组，前提是目标数组的大小已知且足够容纳 Vec 中的元素。
```
let fixed_array: [i32; 3] = numbers.into_iter().collect();
```


> >Vec 严格遵守 Rust 的所有权和生命周期规则，确保在任何时候都不会出现悬垂指针或未初始化的内存。当 Vec 超出作用域时，其内部存储的元素也会被自动释放，避免了内存泄漏。（Vec 对其内部元素拥有所有权。当 Vec 被销毁时，其所有元素也会随之被清理。确保在合适的生命周期范围内管理 Vec 和其元素）
>
  >>Vec 中的所有元素必须是同一种类型。试图添加不同类型元素到 Vec 会导致编译错误。
  >
  >>使用 Vec 的 get(index) 方法代替直接索引访问，以返回一个 `Option<&T>` 或 `Option<&mut T>`，这样在索引无效时不会 `panic`，而是返回 `None`。
  >
  >>当 Vec 的长度达到容量时，再添加新元素会导致自动扩容，这通常涉及内存重新分配和元素复制，可能影响性能。在已知大概元素数量的情况下，可以预估容量并使用 `vec.reserve(n)` 避免频繁扩容
  >
  >> 删除 Vec 中不需要的元素后，可通过 `vec.shrink_to_fit()` 请求减少容量以释放多余的内存。但这并非一定会立即生效，取决于 Rust 编译器和运行时的优化决策。
  >
  >>如果 Vec 仅临时持有数据，并且其生命周期结束后不再需要释放资源，考虑使用 `Vec::into_boxed_slice()` 转换为 `Box<[T]>`，以便在堆上分配内存并在 Vec 超出作用域时自动释放。
  >
  >>在遍历 Vec 期间修改其内容（如删除元素）可能导致未定义行为。通常应避免在遍历时直接修改 Vec，或者使用专用的方法（如 `retain` 或 `drain_filter`）来安全地过滤或删除元素。
  >
  >>对于高度性能敏感的应用，应熟悉 Vec 的内部工作原理（如其内存布局和扩容策略）以及相关的优化技巧。在必要时，可以使用 `unsafe` 代码或第三方库（如 `smallvec`）以满足特定性能需求

##### 1.8哈希表

哈希表是一种常见的结构，用于存储 Key-Value 映射关系，基本在各种语言中都有内置提供。Rust 中的哈希表类型为 HashMap。对一个 HashMap 结构来说，Key 要求是同一种类型，比如是字符串就统一用字符串，是数字就统一用数字。Value 也是一样，要求是同一种类型。Key 和 Value 的类型不需要相同。
Rust 标准库中提供了两种主要的哈希表实现： `std::collections::HashMap` 和 `std::collections::BTreeMap`

> 当需要高效的无序键值存储和查找，且不关心键的顺序时，通常首选 HashMap
> 当需要保持键的排序、期望稳定的遍历顺序，或者对缓存局部性有较高要求时，可以考虑使用 BTreeMap。

1. `std::collections::HashMap`:
		`HashMap<K, V, S>` 是 Rust 最常用的哈希表类型，其中：
		`K`: 键（key）的类型，要求实现 `Eq` 和 `Hash trait`，以确保键可以被正确地哈希并进行相等性检查。
		`V`: 值（value）的类型，可以是任何类型。
		`S`: 哈希状态（hash state）的类型，默认为 `RandomState`，负责生成随机种子以创建哈希函数。也可以指定为其他类型，如 `BuildHasherDefault<FnvHasher>`，以使用特定的哈希函数族。
```
use std::collections::HashMap;
// 创建一个空的 HashMap，键为字符串，值为整数
let mut map: HashMap<String, i32> = HashMap::new();
// 插入键值对
map.insert("apple".to_string(), 1);
map.insert("banana".to_string(), 2);
map.insert("cherry".to_string(), 3);
// 访问和修改值
map.entry("banana").and_modify(|e| *e += 1).or_insert(0);
assert_eq!(map["banana"], 3);  // 修改后的值
```
2. `std::collections::BTreeMap`:
	`BTreeMap` 是一个基于 B-Tree 实现的有序映射，其键值对按照键的排序顺序存储。虽然查找性能不如哈希表理想（平均 O(log n) 时间复杂度）。但主要是保证排序，不存在hash冲突更加稳定，对于连续的键值访问可能有更好的缓存利用率。
```
use std::collections::BTreeMap;
let mut map: BTreeMap<String, i32> = BTreeMap::new();
map.insert("apple".to_string(), 1);
map.insert("banana".to_string(), 2);
map.insert("cherry".to_string(), 3);
// 按键的字母顺序遍历键值对
for (k, v) in &map {
    println!("{}: {}", k, v);
}
```



**常用操作：**
- **迭代器**：通过 `iter()`、`keys()`、`values()` 和 `values_mut()` 方法获取迭代器，用于遍历键值对、仅键或仅值。
- **合并操作**：如 `entry()` 方法提供了插入或更新键值对的便捷方式，支持插入新键值对、更新已有值、忽略已有值或合并值（对于可累加的值类型）。
- **容量管理**：可以通过 `reserve()` 预先分配空间以减少后续插入时的潜在内存重分配，或通过 `shrink_to_fit()` 尝试释放多余容量。
- **克隆与浅拷贝**：由于 HashMap 和 BTreeMap **存储的是引用类型**，克隆它们会创建一个新的容器，但**键值对本身不会被复制**（除非它们实现了 Clone trait）。



