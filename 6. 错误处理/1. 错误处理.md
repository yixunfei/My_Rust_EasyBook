#### 错误分类
---



**可恢复错误（Recoverable Errors）**
可恢复错误是指程序遇到预期的异常情况，但仍有可能通过适当的操作继续执行或优雅地降级服务。这类错误通常用 Result 类型来处理，允许程序在遇到错误时返回有意义的信息，并决定如何响应。

**不可恢复错误（Unrecoverable Errors）**
不可恢复错误指程序遇到严重故障，无法继续执行或无法提供有意义的结果。这类错误通常通过 `panic!` 宏触发，导致程序立即停止执行，打印堆栈跟踪，并进行必要的资源清理（如 `Drop trait` 的实现）。`panic!` 主要用于表示编程错误（如无效的状态、未初始化的变量等），而非预期的运行时错误。
```
fn main() {
    panic!("crash and burn");
}
```

#### `Result` 类型

`Result` 是 Rust 标准库提供的**枚举类型**，用于表示操作的两种可能结果：成功或失败。其定义如下：
```
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

**Result有两个成员：**

- `Ok(T)`
 当函数执行成功并产生预期的结果时，返回一个包含实际结果值的`Ok`变体。例如，如果一个函数旨在读取文件内容并返回字符串，则成功的Result可能是`Ok(String)`，其中 `String` 包含了文件内容。
 
- `Err(E)`
 当函数执行过程中遇到某种错误条件时，返回一个包含错误信息的`Err`变体。**错误类型`E`可以是任何实现了`std::error::Error trait`的类型，或者是用户自定义的错误类型，也可以是预定义的错误类型如`std::io::Error`**。例如，如果上述文件读取函数由于文件不存在或权限问题无法完成任务，它可能会返回`Err(std::io::Error)`，其中包含有关错误的详细信息。

##### Result类型应用情况

1. **函数返回**：当一个函数有可能因各种原因失败时，应将其返回类型声明为Result，以明确表示其可能的成功或失败状态。这样，调用者就必须处理这两种可能性，确保不会忽视潜在的错误。
2. **错误传播**：通过`?`运算符，可以方便地在函数间传播`Result`。当一个函数返回`Result`且在其内部调用了另一个返回`Result`的函数时，使用`?`可以使当前函数在遇到`Err`时立即返回，无需手动检查和包装错误。
3. **错误处理策略**：根据具体需求，调用者可以选择不同的方式来处理Result。
4. **使用模式匹配**（`match`、`if let` 或 `while let`）来明确区分成功和失败情况，对不同结果采取相应行动。
5. **立即失败**：`unwrap()`、`expect()`等方法在遇到错误时立即` panic`。
6. **链式处理**：使用`map()`、`and_then()`、`or_else()`等方法链式处理结果，进行成功路径上的进一步计算或错误处理的链式传递。
7. **失败默认值**：应用 `unwrap_or()`, `unwrap_or_default()` 等方法提供默认值作为失败情况下的备选结果


##### 错误传播

==Rust 通过 `?` 运算符实现了错误传播机制。==在返回 `Result` 的函数或方法中，`?` 可以将当前 `Result` 的 `Err` 值直接返回给调用者，而 Ok 值则会被解包并继续执行后续代码。这极大地简化了错误处理代码的编写：

```
fn read_file(path: &str) -> Result<String, io::Error> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}
```

##### 自定义错误类型

为了提供丰富的错误信息和更好的错误处理体验，通常会定义自定义错误类型。自定义错误类型通常实现 `std::error::Error trait`，以便与其他错误类型兼容，并提供有用的错误信息。可以使用 `thiserror` 或 `anyhow` 等 `crates` 来简化自定义错误类型的定义。
```
pub enum Error{  
    IO(std::io::Error)  
}  
  
impl From<std::io::Error> for Error{  
    fn from(value: std::io::Error) -> Self {  
        Error::IO(value)  
    }  
}
```
##### `unwrap` 和 `expect`
在开发或测试阶段，可以使用 Result 的 `unwrap` 或 `expect` 方法快速获取 Ok 值，同时在遇到 `Err` 时立即触发 `panic!`。这主要用于临时调试或对错误处理有绝对信心的代码片段，不应在生产环境中广泛使用：

```
let value = result.unwrap(); // 如果 result 是 Err，程序会 panic!
let value = result.expect("An informative message on failure"); // 同上，附带自定义消息
```

##### 编译时检查与`#[must_use]`属性

Result类型被标注了`#[must_use]`属性，这意味着编译器会在检测到`Result`值未被适当处理（如赋值、返回、传递给需要Result的函数等）时发出警告。这有助于防止程序员无意中忽视错误处理，确保代码的健壮性


##### `Option` 与错误处理

虽然 `Option` 类型**不是专门用于错误处理**，但在很多情况下，它用于**表示可能缺失的值**，可以作为简单的错误处理机制。`Option` 提供了 `map`、`and_then`、`unwrap_or`、`unwrap_or_else` 等方法，便于在值存在时进行进一步处理，或在值不存在时提供默认值或触发备用逻辑


#### panic! 与异常处理

`panic! `宏触发程序的异常终止，打印堆栈跟踪，并清理相关资源。尽管它常用于表示不可恢复的编程错误，但在某些场景下也可用于临时的错误处理。然而，过度依赖 `panic!` 可能导致程序不够健壮，因此通常建议使用 `Result` 进行更精细的错误控制。

> **对应 panic 时的栈展开或终止**:
>  
 当出现 `panic` 时，程序默认会开始 **展开**（_unwinding_），这意味着 **Rust 会回溯栈并清理它遇到的每一个函数的数据**，不过这个回溯并清理的过程有很多工作。另一种选择是直接 **终止**（_abort_），这会不清理数据就退出程序。那么程序所使用的内存需要由操作系统来清理。如果你需要项目的最终二进制文件越小越好，panic 时通过在 _Cargo.toml_ 的 `[profile]` 部分增加 `panic = 'abort'`，可以由展开切换为终止。例如，如果你想要在release模式中 panic 时直接终止：
```
 [profile.release]
 panic = 'abort'
```


#### 断言(`assert!`)

断言是一种在编程中用于在运行时检查程序内部状态是否符合预期的机制，主要**用于调试和验证**程序的正确性。在Rust中，断言主要通过标准库提供的`assert!`宏来实现。

##### `assert!`宏的使用

`assert`!宏接受一个布尔表达式作为参数，如果该表达式的值为 `true`，则断言通过，程序继续执行；如果为 `false`，则断言失败，程序会立即停止执行（`panic!`），并打印出包含断言条件和可选自定义消息的错误信息。这对于捕获开发阶段的逻辑错误非常有用，因为它允许程序员在特定条件下强制程序崩溃，以便快速识别和修复问题。
基本语法如下：
```
assert!(condition, optional_message);
```
- `condition`: 这是一个布尔表达式，表示您希望在运行时保持为真的条件。例如，某个变量的值应在某个范围内，或者两个值应当相等等。
- `optional_message`: 这是一个可选的字符串字面量或字符串生成式，当断言失败时，它会被打印出来以提供额外的上下文信息。如果省略此参数，`assert!`宏会生成一个默认的消息。
