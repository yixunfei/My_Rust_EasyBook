FFI（Foreign Function Interface）是一种允许Rust代码与非Rust编写的库或程序（通常是指用C、C++或其他语言编写的库）进行互操作的技术。FFI使得Rust能够调用外部库的功能，同时也可以让外部库调用Rust编写的函数。

## 外部函数声明 extern

在Rust中，要调用外部库的函数，首先需要使用 `extern` 关键字在Rust代码中对外部函数进行声明。声明包括函数名、参数类型、返回类型以及调用约定（如`"C"`或`"system"`）。调用约定指定如何在函数调用过程中传递参数和返回值，以及如何处理栈帧。对于大多数与C库的互操作，使用标准的C调用约定（`"C"`）即可。

```Rust
extern "C" {
    fn some_external_function(arg1: i32, arg2: *const c_char) -> c_int;
}
```
上面代码声明了一个名为 `some_external_function` 的外部函数，它接受一个i32类型的参数和一个指向 `c_char`（对应C语言中的 `char`）的常量指针，返回一个 `c_int`（对应C语言中的 `int`）。


## 类型映射

为了与外部库进行互操作，Rust提供了与C语言类型兼容的数据类型。这些类型位于`std::os::raw模块`中，例如：

 - `c_int`, `c_uint`: 对应C语言中的 `int` 和 `unsigned int`。
 - `c_char`, `c_uchar`: 对应C语言中的 `char` 和 `unsigned char`。
 - `c_void`: 表示C语言中的 `void` 类型，常用于指针类型如 `*const c_void`或`*mut c_void`。
 - `c_float`, `c_double`: 对应C语言中的 `float` 和 `double`。

此外，Rust还提供了`std::ffi`模块，其中包含了处理C风格字符串的类型，如：

- `CString`: 表示一个以\0结尾的、可释放的C字符串。用于创建和传递C库期望的字符串指针。
- `CStr`: 表示一个不可变的C字符串切片。用于安全地从*const c_char指针中解引用和操作C字符串内容。

```Rust
use std::os::raw::{c_int, c_char};

fn main() {
    let age: c_int = 30;
    let name: *const c_char = std::ffi::CString::new("Alice").unwrap().into_raw();
}
```

## 裸指针与生命周期

由于C语言不具有Rust那样的所有权和生命周期概念，所以在FFI中通常需要直接读取操作内存地址来传递数据（对应的直接指向地址的引用称为：裸指针（`*const T`和`*mut T`），见下一节）。裸指针不涉及所有权转移和生命周期管理，需要确保在外部函数调用期间指针有效，并在适当的时候释放相关资源。

```Rust
use std::ffi::CString;

extern "C" {
    fn print_name(name: *const c_char);
}

fn main() {
    let rust_string = "Bob".to_owned();
    let c_string = CString::new(rust_string).unwrap();
    
    unsafe {
        print_name(c_string.as_ptr());
    }
    
    // 在这里释放C字符串资源
    drop(c_string);
}
```

## 安全性与unsafe块

调用外部函数以及处理与之相关的裸指针操作通常需要在 `unsafe` 块中进行。这是因为Rust编译器无法验证外部函数是否遵守Rust的安全规则，如是否存在悬垂指针、是否正确释放资源等。需要确保在 `unsafe` 代码块中遵守所有必要的内存安全和类型安全约束。

```Rust
extern "C" {
    fn allocate(size: usize) -> *mut u8;
    fn deallocate(ptr: *mut u8, size: usize);
}

fn get_zeroed_buffer(size: usize) -> Vec<u8> {
    let mut buffer: Vec<u8> = Vec::with_capacity(size);
    let ptr = buffer.as_mut_ptr();

    unsafe {
        // 使用C库分配内存
        let raw_ptr = allocate(size);
        // 将C库分配的内存复制到Rust的Vec中
        std::ptr::copy_nonoverlapping(raw_ptr, ptr, size);
        // 使用C库释放内存
        deallocate(raw_ptr, size);
    }

    buffer.set_len(size);
    buffer
}

fn main() {
    let buffer = get_zeroed_buffer(100);
    println!("{:?}", buffer);
}

```

## 异常处理与错误报告

Rust的错误处理机制基于 `Result` 类型和 `?` 运算符，而许多C库则通过返回错误码或者抛出异常来报告错误。在Rust中调用这样的C库函数时，通常需要将返回值解析为 `Rust` 的 `Result`类型，或者使用`catch_unwind`等机制来捕获潜在的异常。

```Rust
use std::result::Result;
use std::error::Error;

type FfiResult<T> = Result<T, Box<dyn Error>>;

extern "C" {
    fn divide(a: f64, b: f64) -> f64;
}

fn safe_divide(a: f64, b: f64) -> FfiResult<f64> {
    if b == 0.0 {
        return Err(Box::new(std::num::ZeroDivisionError::new(())));
    }

    let result = unsafe { divide(a, b) };
    Ok(result)
}

fn main() {
    match safe_divide(10.0, 2.0) {
        Ok(value) => println!("Result: {}", value),
        Err(error) => eprintln!("Error: {}", error),
    }
}

```

## 库绑定生成工具

虽然手动编写FFI声明和转换代码是可行的，但为了提高效率和减少错误，通常会使用库绑定生成工具，如`bindgen`。这些工具可以根据C库的头文件自动生成Rust的FFI声明和类型映射代码，极大地简化了FFI集成的过程。


假设有一个名为example.h的C头文件：
```C
typedef struct {
    int x;
    int y;
} Point;

Point make_point(int x, int y);

void do_something_with_point(Point *p);
```

使用bindgen生成Rust绑定：
```shell
bindgen example.h --output bindings.rs
```

生成的bindings.rs文件将包含类似以下内容：
```Rust
/* Automatically generated by rust-bindgen */

pub type Point = Struct_Point;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Struct_Point {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}

extern "C" {
    pub fn make_point(x: ::std::os::raw::c_int, y: ::std::os::raw::c_int) -> Point;
    pub fn do_something_with_point(p: *mut Point);
}

```


Rust作为库供其他语言调用

```Rust
use std::os::raw::c_int;

#[no_mangle]
pub extern "C" fn add_numbers(a: c_int, b: c_int) -> c_int {
    a + b
}
```


## 不同语言的使用示例：

使用对应依赖库，如:
```toml
[dependencies]
rlua = "0.20.0"
wasm-bindgen = "0.2.92"
jnix = "0.5.1"
...
```

具体各语言FFI调用如下
### 汇编

由于汇编语言直接对应于特定的机器指令，Rust通常通过内联汇编（inline assembly）来直接插入和执行汇编代码。并提供`asm!`宏进行直接执行汇编指令。

使用 `asm!` 宏调用一条加法指令示例：

```Rust
// 假设我们有一个简单的汇编加法函数，它将两个寄存器的值相加并存储在第一个寄存器中
// 这里仅作示例，实际汇编代码需根据目标架构编写

#[cfg(target_arch = "x86_64")]
fn inline_asm_add(a: u64, b: u64) -> u64 {
    let mut sum: u64;
    unsafe {
        asm!(
            // 汇编代码
            "add rax, rbx",
            // 输出约束
            out("rax") sum,
            // 输入约束
            in("rax") a,
            in("rbx") b,
            options(nostack)
        );
    }
    sum
}

fn main() {
    let a = 10;
    let b = 20;
    let sum = inline_asm_add(a, b);
    println!("Sum: {}", sum);
}
```


### C++

Rust调用C++库通常通过声明遵循C ABI的C++函数（通常是`extern "C"`），或者使用C++编译器生成的C接口（如`extern "C" __declspec(dllexport)`）。以下是一个调用C++库的简单示例：

```Rust
// 假设有一个C++库，其中包含一个导出的C接口函数：
// extern "C" int add(int a, int b);

extern "C" {
    fn add(a: i32, b: i32) -> i32;
}

fn main() {
    let result = unsafe { add(3, 5) };
    println!("Result from C++ library: {}", result);
}
```


### Python

Rust可以通过`pyo3`库创建Python扩展模块，如下示例：

```Rust
// 导入pyo3库
use pyo3::prelude::*;

// 定义一个Python可调用的Rust函数
#[pyfunction]
fn add(a: i32, b: i32) -> PyResult<i32> {
    Ok(a + b)
}

// 导出模块
#[pymodule]
fn my_rust_module(_py: Python, m: &PyModule) -> PyResult<()> {
    m.add_function(wrap_pyfunction!(add, m)?)?;
    Ok(())
}
```
编译并安装这个Rust库后，就可以在Python中导入并调用add函数：
```python
import my_rust_module

result = my_rust_module.add(3, 5)
print("Result from Rust library:", result)
```


### Java

Rust调用Java代码通常通过Java的JNI（Java Native Interface）。以下是一个使用`jnix`库调用Java方法的示例：

```rust
use jnix::{
    jni::{objects::JObject, JNIEnv},
    JnixEnv, FromJava, IntoJava,
};

// Rust type definition
#[derive(Default, FromJava, IntoJava)]
#[jnix(package = "my.package")]
pub struct MyData {
    number: i32,
    string: String,
}

// A JNI function called from Java that creates a `MyData` Rust type, converts it to a Java
// type and returns it.
#[no_mangle]
#[allow(non_snake_case)]
pub extern "system" fn Java_my_package_JniClass_getData<'env>(
    env: JNIEnv<'env>,
    _this: JObject<'env>,
    data: JObject<'env>,
) -> JObject<'env> {
    // Create the `JnixEnv` wrapper
    let env = JnixEnv::from(env);

    // Convert parameter to Rust type
    let data = MyData::from_java(&env, data);

    // Create a new `MyData` object by converting from the Rust type. Since a smart pointer is
    // returned from `into_java`, the inner object must be "leaked" sothat the garbage collector
    // can own it afterwards
    data.into_java(&env).forget()
}
```

```Java
package my.package;

public class MyData {
    public MyData(int number, String string) {
        // This is the constructor that is called by the generated `IntoJava` code
        //
        // Note that the fields don't actually have to exist, the only thing that's necessary
        // is for the target Java class to have a constructor with the expected type signature
        // following the field order of the Rust type.
    }

    // These getters are called by the generated `FromJava` code
    public int getNumber() {
        return 10;
    }

    public String getString() {
        return "string value";
    }
}
```

### C\#

Rust调用C\#代码通常通过`P/Invoke`（Platform Invocation Services）。使用`winapi`库调用C\#方法的示例：

```Rust
// 假设有一个C#库，其中包含一个公开的静态方法：
// public static class MyCSharpClass {
//     [DllImport("my_csharp_library.dll")]
//     public static extern int Add(int a, int b);
// }

extern "system" {
    fn Add(a: i32, b: i32) -> i32;
}

fn main() {
    let result = unsafe { Add(3, 5) };
    println!("Result from C# library: {}", result);
}
```


### Golang

Rust调用Go代码通常通过`cgo`（C Go interface）。使用`bindgen`生成Go接口示例如下：（假设已有对应的Go库）：

```Rust
// 生成的Go接口
#[link(name = "my_go_library")]
extern "C" {
    fn Add(a: i32, b: i32) -> i32;
}

fn main() {
    let result = unsafe { Add(3, 5) };
    println!("Result from Go library: {}", result);
}
```


### JavaScript

Rust通过`wasm-bindgen`库创建`WebAssembly`模块，并在JavaScript中调用。

```Rust
// 使用wasm-bindgen库
use wasm_bindgen::prelude::*;

// 定义一个JavaScript可调用的Rust函数
#[wasm_bindgen]
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
```
编译并加载这个`WebAssembly`模块后，就可以在JavaScript中调用add函数：
```javascript
import * as wasm from './my_wasm_module';
console.log("Result from Rust library:", wasm.add(3, 5));
```

### Lua
在Rust中调用Lua脚本或函数，通常使用`rlua库`。

```Rust
use rlua::{Context, Lua, Result};

fn main() -> Result<()> {
    // 创建一个新的Lua上下文
    let lua = Lua::new();

    // 执行一个简单的Lua脚本
    lua.exec::<_, ()>(r#"print("Hello from Lua!")"#)?;

    // 注册一个Rust函数供Lua调用
    lua.context(|ctx| {
        ctx.load(r#"
            function call_rust_add(a, b)
                local result = rust_add(a, b)
                print(string.format("Rust added: %d + %d = %d", a, b, result))
            end
        "#)?
        .exec()?;

        // 注册Rust函数`rust_add`
        ctx.set_function("rust_add", |ctx, (a, b): (i32, i32)| {
            Ok(a + b)
        })?;

        // 调用Lua函数`call_rust_add`
        ctx.load("call_rust_add(3, 5)").exec()?;
        Ok(())
    })?;

    Ok(())
}
```
